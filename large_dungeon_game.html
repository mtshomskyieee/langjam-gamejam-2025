<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dungeon Game</title>
    <style>
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
        }
        
        #menu-bar {
            background: #2a2a2a;
            padding: 10px;
            display: flex;
            gap: 10px;
            border-bottom: 2px solid #444;
        }
        
        .menu-button {
            background: #444;
            color: #fff;
            border: 1px solid #666;
            padding: 8px 16px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        .menu-button:hover {
            background: #555;
        }
        
        .dropdown {
            position: relative;
            display: inline-block;
        }
        
        .dropdown-content {
            display: none;
            position: absolute;
            background: #333;
            min-width: 200px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 1000;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #555;
            border-radius: 4px;
            top: 100%;
            left: 0;
            margin-top: 5px;
        }
        
        .dropdown-content.show {
            display: block;
        }
        
        .dropdown-content div {
            padding: 10px;
            border-bottom: 1px solid #444;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: calc(100vh - 50px);
            overflow: hidden;
        }
        
        #game-canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            image-rendering: pixelated;
        }
        
        #dialog-panel {
            position: fixed;
            right: -400px;
            top: 60px;
            width: 350px;
            height: calc(100vh - 60px);
            background: #2a2a2a;
            border-left: 2px solid #444;
            transition: right 0.3s;
            padding: 20px;
            overflow-y: auto;
        }
        
        #dialog-panel.show {
            right: 0;
        }
        
        #dialog-content {
            margin-bottom: 20px;
        }
        
        #dialog-input {
            width: 100%;
            padding: 10px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
        }
        
        #dialog-close {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #444;
            color: #fff;
            border: 1px solid #666;
            padding: 5px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 16px;
            z-index: 10;
        }
        
        #dialog-close:hover {
            background: #555;
        }
        
        .interaction-text {
            position: absolute;
            background: rgba(0,0,0,0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 100;
            font-size: 12px;
        }
        
        .popup-text {
            position: absolute;
            background: rgba(255,255,0,0.9);
            color: #000;
            padding: 5px 10px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 101;
            font-size: 12px;
            animation: fadeOut 3s forwards;
        }
        
        @keyframes fadeOut {
            0% { opacity: 1; }
            70% { opacity: 1; }
            100% { opacity: 0; }
        }
        
        #splash-screen {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        
        #splash-screen.show {
            display: flex;
        }
        
        #splash-content {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            max-width: 600px;
            width: 90%;
            text-align: center;
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        #splash-title {
            font-size: 2.5em;
            margin: 0 0 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            color: #ffd700;
        }
        
        #splash-text {
            font-size: 1.2em;
            line-height: 1.8;
            margin: 20px 0;
            color: #ffffff;
        }
        
        #splash-text p {
            margin: 10px 0;
        }
        
        #splash-close {
            margin-top: 30px;
            padding: 15px 40px;
            font-size: 1.2em;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        
        #splash-close:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        
        #splash-close:active {
            transform: translateY(0);
        }
        
    </style>
</head>
<body>
    
    <div id="menu-bar">
        <button class="menu-button" onclick="game.saveGame()">Save</button>
        <button class="menu-button" onclick="document.getElementById('load-input').click()">
            Load
            <input type="file" id="load-input" accept=".json" style="display:none" onchange="game.loadGame(event)">
        </button>
        <div class="dropdown">
            <button class="menu-button" onclick="toggleDropdown('status-dropdown')">Status</button>
            <div id="status-dropdown" class="dropdown-content">
                <div id="status-content"></div>
            </div>
        </div>
        <div class="dropdown">
            <button class="menu-button" onclick="toggleDropdown('inventory-dropdown')">Inventory</button>
            <div id="inventory-dropdown" class="dropdown-content">
                <div id="inventory-content"></div>
            </div>
        </div>
        <div class="dropdown">
            <button class="menu-button" onclick="toggleDropdown('chat-dropdown')">Chat History</button>
            <div id="chat-dropdown" class="dropdown-content">
                <div id="chat-content"></div>
            </div>
        </div>
        <div class="dropdown">
            <button class="menu-button" onclick="toggleDropdown('quest-dropdown')">Quest-Status</button>
            <div id="quest-dropdown" class="dropdown-content">
                <div id="quest-content"></div>
            </div>
        </div>
    </div>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
    </div>
    <div id="dialog-panel">
        <button id="dialog-close" onclick="game.closeDialog()">Ã— Close</button>
        <div id="dialog-content"></div>
        <input type="text" id="dialog-input" placeholder="Type message..." style="display:none" onkeypress="handleDialogInput(event)">
    </div>
    <div id="splash-screen">
        <div id="splash-content">
            <h1 id="splash-title"></h1>
            <div id="splash-text"></div>
            <button id="splash-close" onclick="game.closeSplashScreen()">Start Game</button>
        </div>
    </div>
    <script>
        function toggleDropdown(id) {
            const dropdown = document.getElementById(id);
            dropdown.classList.toggle('show');
        }
        
        function handleDialogInput(event) {
            if (event.key === 'Enter') {
                const input = document.getElementById('dialog-input');
                const message = input.value;
                if (message.trim()) {
                    game.handleDialogInput(message);
                    input.value = '';
                }
            }
        }
        
        // Close dropdowns when clicking outside
        window.onclick = function(event) {
            if (!event.target.matches('.menu-button')) {
                const dropdowns = document.getElementsByClassName('dropdown-content');
                for (let dropdown of dropdowns) {
                    if (dropdown.classList.contains('show')) {
                        dropdown.classList.remove('show');
                    }
                }
            }
        }
    </script>
        
    <script>
        const INITIAL_GAME_STATE = {
  "world": {
    "width": 1000,
    "height": 30
  },
  "user": {
    "unique_name": "player",
    "position": [
      5,
      15
    ],
    "health": 100,
    "experience": 0,
    "level": 1,
    "inventory": [],
    "context": "adventurer",
    "talked_to_npcs": [],
    "showHealthBar": false
  },
  "terrain": {},
  "furniture": [
    {
      "name": "grass",
      "placement": {
        "type": "all"
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          0,
          0
        ],
        "coord2": [
          80,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          0,
          29
        ],
        "coord2": [
          80,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          80,
          0
        ],
        "coord2": [
          80,
          12
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          80,
          17
        ],
        "coord2": [
          80,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          81,
          0
        ],
        "coord2": [
          160,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          81,
          29
        ],
        "coord2": [
          160,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          160,
          0
        ],
        "coord2": [
          160,
          10
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          160,
          20
        ],
        "coord2": [
          160,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          161,
          0
        ],
        "coord2": [
          240,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          161,
          29
        ],
        "coord2": [
          240,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          240,
          0
        ],
        "coord2": [
          240,
          14
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          240,
          16
        ],
        "coord2": [
          240,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          241,
          0
        ],
        "coord2": [
          320,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          241,
          29
        ],
        "coord2": [
          320,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          320,
          0
        ],
        "coord2": [
          320,
          8
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          320,
          22
        ],
        "coord2": [
          320,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          321,
          0
        ],
        "coord2": [
          400,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          321,
          29
        ],
        "coord2": [
          400,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          400,
          0
        ],
        "coord2": [
          400,
          13
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          400,
          17
        ],
        "coord2": [
          400,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          401,
          0
        ],
        "coord2": [
          480,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          401,
          29
        ],
        "coord2": [
          480,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          480,
          0
        ],
        "coord2": [
          480,
          11
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          480,
          19
        ],
        "coord2": [
          480,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          481,
          0
        ],
        "coord2": [
          560,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          481,
          29
        ],
        "coord2": [
          560,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          560,
          0
        ],
        "coord2": [
          560,
          9
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          560,
          21
        ],
        "coord2": [
          560,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          561,
          0
        ],
        "coord2": [
          640,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          561,
          29
        ],
        "coord2": [
          640,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          640,
          0
        ],
        "coord2": [
          640,
          12
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          640,
          18
        ],
        "coord2": [
          640,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          641,
          0
        ],
        "coord2": [
          720,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          641,
          29
        ],
        "coord2": [
          720,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          720,
          0
        ],
        "coord2": [
          720,
          7
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          720,
          23
        ],
        "coord2": [
          720,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          721,
          0
        ],
        "coord2": [
          800,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          721,
          29
        ],
        "coord2": [
          800,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          800,
          0
        ],
        "coord2": [
          800,
          12
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          800,
          18
        ],
        "coord2": [
          800,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          801,
          0
        ],
        "coord2": [
          900,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          801,
          29
        ],
        "coord2": [
          900,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          900,
          0
        ],
        "coord2": [
          900,
          5
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          900,
          25
        ],
        "coord2": [
          900,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          901,
          0
        ],
        "coord2": [
          999,
          0
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          901,
          29
        ],
        "coord2": [
          999,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          901,
          0
        ],
        "coord2": [
          901,
          13
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          901,
          17
        ],
        "coord2": [
          901,
          29
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          950,
          5
        ],
        "coord2": [
          999,
          5
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          950,
          24
        ],
        "coord2": [
          999,
          24
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          950,
          5
        ],
        "coord2": [
          950,
          13
        ]
      }
    },
    {
      "name": "wall",
      "placement": {
        "type": "range",
        "coord1": [
          950,
          17
        ],
        "coord2": [
          950,
          24
        ]
      }
    }
  ],
  "mythics": [
    {
      "unique_name": "gem_room1_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        15,
        10
      ]
    },
    {
      "unique_name": "gem_room1_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        45,
        20
      ]
    },
    {
      "unique_name": "gem_room2_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        110,
        15
      ]
    },
    {
      "unique_name": "gem_room2_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        130,
        5
      ]
    },
    {
      "unique_name": "gem_room3_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        190,
        18
      ]
    },
    {
      "unique_name": "gem_room3_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        210,
        8
      ]
    },
    {
      "unique_name": "gem_room4_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        270,
        12
      ]
    },
    {
      "unique_name": "gem_room4_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        290,
        22
      ]
    },
    {
      "unique_name": "gem_room5_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        350,
        16
      ]
    },
    {
      "unique_name": "gem_room5_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        370,
        6
      ]
    },
    {
      "unique_name": "gem_room6_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        430,
        14
      ]
    },
    {
      "unique_name": "gem_room6_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        450,
        24
      ]
    },
    {
      "unique_name": "gem_room7_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        510,
        11
      ]
    },
    {
      "unique_name": "gem_room7_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        530,
        21
      ]
    },
    {
      "unique_name": "gem_room8_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        590,
        15
      ]
    },
    {
      "unique_name": "gem_room8_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        610,
        5
      ]
    },
    {
      "unique_name": "gem_room9_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        670,
        19
      ]
    },
    {
      "unique_name": "gem_room9_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        690,
        9
      ]
    },
    {
      "unique_name": "gem_room10_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        750,
        13
      ]
    },
    {
      "unique_name": "gem_room10_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        770,
        23
      ]
    },
    {
      "unique_name": "gem_room11_1",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        830,
        17
      ]
    },
    {
      "unique_name": "gem_room11_2",
      "can_pickup": true,
      "picked_up": false,
      "catch_message": "Not now",
      "position": [
        850,
        7
      ]
    }
  ],
  "items": [
    {
      "unique_name": "potion_start_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        20,
        5
      ]
    },
    {
      "unique_name": "potion_start_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        50,
        25
      ]
    },
    {
      "unique_name": "potion_goblin_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        120,
        8
      ]
    },
    {
      "unique_name": "potion_goblin_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        140,
        22
      ]
    },
    {
      "unique_name": "potion_treasure_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        200,
        3
      ]
    },
    {
      "unique_name": "potion_treasure_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        220,
        26
      ]
    },
    {
      "unique_name": "potion_orc_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        280,
        6
      ]
    },
    {
      "unique_name": "potion_orc_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        300,
        24
      ]
    },
    {
      "unique_name": "potion_crystal_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        360,
        4
      ]
    },
    {
      "unique_name": "potion_crystal_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        380,
        25
      ]
    },
    {
      "unique_name": "potion_shadow_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        440,
        7
      ]
    },
    {
      "unique_name": "potion_shadow_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        460,
        23
      ]
    },
    {
      "unique_name": "potion_fire_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        520,
        5
      ]
    },
    {
      "unique_name": "potion_fire_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        540,
        24
      ]
    },
    {
      "unique_name": "potion_ice_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        600,
        8
      ]
    },
    {
      "unique_name": "potion_ice_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        620,
        21
      ]
    },
    {
      "unique_name": "potion_library_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        680,
        3
      ]
    },
    {
      "unique_name": "potion_library_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        700,
        26
      ]
    },
    {
      "unique_name": "potion_dragon_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        760,
        6
      ]
    },
    {
      "unique_name": "potion_dragon_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        780,
        23
      ]
    },
    {
      "unique_name": "potion_dragon_3",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        780,
        8
      ]
    },
    {
      "unique_name": "potion_final_1",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        810,
        5
      ]
    },
    {
      "unique_name": "potion_final_2",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        870,
        5
      ]
    },
    {
      "unique_name": "potion_final_3",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        810,
        25
      ]
    },
    {
      "unique_name": "potion_final_4",
      "item_type": "item-heal",
      "can_pickup": true,
      "picked_up": false,
      "effect": null,
      "damage": 1,
      "catch_message": "Not now",
      "position": [
        870,
        25
      ]
    }
  ],
  "monsters": [
    {
      "unique_name": "guard_start_1",
      "monster_type": "monster-static",
      "health": 2,
      "max_health": 2,
      "experience": 20,
      "defeated": false,
      "position": [
        30,
        15
      ]
    },
    {
      "unique_name": "guard_start_2",
      "monster_type": "monster-static",
      "health": 2,
      "max_health": 2,
      "experience": 20,
      "defeated": false,
      "position": [
        60,
        15
      ]
    },
    {
      "unique_name": "ninja_start",
      "monster_type": "monster-dynamic",
      "health": 2,
      "max_health": 2,
      "experience": 25,
      "defeated": false,
      "position": [
        40,
        20
      ]
    },
    {
      "unique_name": "boss_start",
      "monster_type": "monster-boss",
      "health": 8,
      "max_health": 8,
      "experience": 100,
      "defeated": false,
      "position": [
        50,
        10
      ]
    },
    {
      "unique_name": "goblin_den_1",
      "monster_type": "monster-static",
      "health": 3,
      "max_health": 3,
      "experience": 30,
      "defeated": false,
      "position": [
        100,
        15
      ]
    },
    {
      "unique_name": "goblin_den_2",
      "monster_type": "monster-static",
      "health": 3,
      "max_health": 3,
      "experience": 30,
      "defeated": false,
      "position": [
        120,
        5
      ]
    },
    {
      "unique_name": "goblin_den_3",
      "monster_type": "monster-static",
      "health": 3,
      "max_health": 3,
      "experience": 30,
      "defeated": false,
      "position": [
        140,
        25
      ]
    },
    {
      "unique_name": "ninja_goblin",
      "monster_type": "monster-dynamic",
      "health": 3,
      "max_health": 3,
      "experience": 35,
      "defeated": false,
      "position": [
        110,
        20
      ]
    },
    {
      "unique_name": "boss_goblin",
      "monster_type": "monster-boss",
      "health": 12,
      "max_health": 12,
      "experience": 150,
      "defeated": false,
      "position": [
        130,
        15
      ]
    },
    {
      "unique_name": "vault_guard_1",
      "monster_type": "monster-static",
      "health": 4,
      "max_health": 4,
      "experience": 40,
      "defeated": false,
      "position": [
        180,
        15
      ]
    },
    {
      "unique_name": "vault_guard_2",
      "monster_type": "monster-static",
      "health": 4,
      "max_health": 4,
      "experience": 40,
      "defeated": false,
      "position": [
        200,
        8
      ]
    },
    {
      "unique_name": "vault_guard_3",
      "monster_type": "monster-static",
      "health": 4,
      "max_health": 4,
      "experience": 40,
      "defeated": false,
      "position": [
        220,
        22
      ]
    },
    {
      "unique_name": "ninja_vault",
      "monster_type": "monster-dynamic",
      "health": 4,
      "max_health": 4,
      "experience": 45,
      "defeated": false,
      "position": [
        190,
        20
      ]
    },
    {
      "unique_name": "boss_vault",
      "monster_type": "monster-boss",
      "health": 16,
      "max_health": 16,
      "experience": 200,
      "defeated": false,
      "position": [
        200,
        15
      ]
    },
    {
      "unique_name": "orc_warrior_1",
      "monster_type": "monster-static",
      "health": 5,
      "max_health": 5,
      "experience": 50,
      "defeated": false,
      "position": [
        260,
        15
      ]
    },
    {
      "unique_name": "orc_warrior_2",
      "monster_type": "monster-static",
      "health": 5,
      "max_health": 5,
      "experience": 50,
      "defeated": false,
      "position": [
        280,
        10
      ]
    },
    {
      "unique_name": "orc_warrior_3",
      "monster_type": "monster-static",
      "health": 5,
      "max_health": 5,
      "experience": 50,
      "defeated": false,
      "position": [
        300,
        20
      ]
    },
    {
      "unique_name": "orc_warrior_4",
      "monster_type": "monster-static",
      "health": 4,
      "max_health": 4,
      "experience": 40,
      "defeated": false,
      "position": [
        270,
        5
      ]
    },
    {
      "unique_name": "ninja_orc",
      "monster_type": "monster-dynamic",
      "health": 5,
      "max_health": 5,
      "experience": 55,
      "defeated": false,
      "position": [
        270,
        20
      ]
    },
    {
      "unique_name": "boss_orc",
      "monster_type": "monster-boss",
      "health": 20,
      "max_health": 20,
      "experience": 250,
      "defeated": false,
      "position": [
        280,
        15
      ]
    },
    {
      "unique_name": "crystal_guard_1",
      "monster_type": "monster-static",
      "health": 5,
      "max_health": 5,
      "experience": 50,
      "defeated": false,
      "position": [
        340,
        15
      ]
    },
    {
      "unique_name": "crystal_guard_2",
      "monster_type": "monster-static",
      "health": 5,
      "max_health": 5,
      "experience": 50,
      "defeated": false,
      "position": [
        360,
        10
      ]
    },
    {
      "unique_name": "crystal_guard_3",
      "monster_type": "monster-static",
      "health": 5,
      "max_health": 5,
      "experience": 50,
      "defeated": false,
      "position": [
        380,
        20
      ]
    },
    {
      "unique_name": "ninja_crystal",
      "monster_type": "monster-dynamic",
      "health": 5,
      "max_health": 5,
      "experience": 55,
      "defeated": false,
      "position": [
        350,
        20
      ]
    },
    {
      "unique_name": "boss_crystal",
      "monster_type": "monster-boss",
      "health": 20,
      "max_health": 20,
      "experience": 250,
      "defeated": false,
      "position": [
        360,
        15
      ]
    },
    {
      "unique_name": "shadow_beast_1",
      "monster_type": "monster-static",
      "health": 6,
      "max_health": 6,
      "experience": 60,
      "defeated": false,
      "position": [
        420,
        15
      ]
    },
    {
      "unique_name": "shadow_beast_2",
      "monster_type": "monster-static",
      "health": 6,
      "max_health": 6,
      "experience": 60,
      "defeated": false,
      "position": [
        440,
        8
      ]
    },
    {
      "unique_name": "shadow_beast_3",
      "monster_type": "monster-static",
      "health": 6,
      "max_health": 6,
      "experience": 60,
      "defeated": false,
      "position": [
        460,
        22
      ]
    },
    {
      "unique_name": "ninja_shadow",
      "monster_type": "monster-dynamic",
      "health": 6,
      "max_health": 6,
      "experience": 65,
      "defeated": false,
      "position": [
        430,
        20
      ]
    },
    {
      "unique_name": "boss_shadow",
      "monster_type": "monster-boss",
      "health": 24,
      "max_health": 24,
      "experience": 300,
      "defeated": false,
      "position": [
        440,
        15
      ]
    },
    {
      "unique_name": "fire_elemental_1",
      "monster_type": "monster-static",
      "health": 6,
      "max_health": 6,
      "experience": 60,
      "defeated": false,
      "position": [
        500,
        15
      ]
    },
    {
      "unique_name": "fire_elemental_2",
      "monster_type": "monster-static",
      "health": 6,
      "max_health": 6,
      "experience": 60,
      "defeated": false,
      "position": [
        520,
        9
      ]
    },
    {
      "unique_name": "fire_elemental_3",
      "monster_type": "monster-static",
      "health": 6,
      "max_health": 6,
      "experience": 60,
      "defeated": false,
      "position": [
        540,
        21
      ]
    },
    {
      "unique_name": "ninja_fire",
      "monster_type": "monster-dynamic",
      "health": 6,
      "max_health": 6,
      "experience": 65,
      "defeated": false,
      "position": [
        510,
        20
      ]
    },
    {
      "unique_name": "boss_fire",
      "monster_type": "monster-boss",
      "health": 24,
      "max_health": 24,
      "experience": 300,
      "defeated": false,
      "position": [
        520,
        15
      ]
    },
    {
      "unique_name": "ice_guardian_1",
      "monster_type": "monster-static",
      "health": 7,
      "max_health": 7,
      "experience": 70,
      "defeated": false,
      "position": [
        580,
        15
      ]
    },
    {
      "unique_name": "ice_guardian_2",
      "monster_type": "monster-static",
      "health": 7,
      "max_health": 7,
      "experience": 70,
      "defeated": false,
      "position": [
        600,
        11
      ]
    },
    {
      "unique_name": "ice_guardian_3",
      "monster_type": "monster-static",
      "health": 7,
      "max_health": 7,
      "experience": 70,
      "defeated": false,
      "position": [
        620,
        19
      ]
    },
    {
      "unique_name": "ninja_ice",
      "monster_type": "monster-dynamic",
      "health": 7,
      "max_health": 7,
      "experience": 75,
      "defeated": false,
      "position": [
        590,
        20
      ]
    },
    {
      "unique_name": "boss_ice",
      "monster_type": "monster-boss",
      "health": 28,
      "max_health": 28,
      "experience": 350,
      "defeated": false,
      "position": [
        600,
        15
      ]
    },
    {
      "unique_name": "librarian_guard_1",
      "monster_type": "monster-static",
      "health": 7,
      "max_health": 7,
      "experience": 70,
      "defeated": false,
      "position": [
        660,
        15
      ]
    },
    {
      "unique_name": "librarian_guard_2",
      "monster_type": "monster-static",
      "health": 7,
      "max_health": 7,
      "experience": 70,
      "defeated": false,
      "position": [
        680,
        7
      ]
    },
    {
      "unique_name": "librarian_guard_3",
      "monster_type": "monster-static",
      "health": 7,
      "max_health": 7,
      "experience": 70,
      "defeated": false,
      "position": [
        700,
        23
      ]
    },
    {
      "unique_name": "ninja_library",
      "monster_type": "monster-dynamic",
      "health": 7,
      "max_health": 7,
      "experience": 75,
      "defeated": false,
      "position": [
        670,
        20
      ]
    },
    {
      "unique_name": "boss_library",
      "monster_type": "monster-boss",
      "health": 28,
      "max_health": 28,
      "experience": 350,
      "defeated": false,
      "position": [
        680,
        15
      ]
    },
    {
      "unique_name": "dragon_minion_1",
      "monster_type": "monster-static",
      "health": 8,
      "max_health": 8,
      "experience": 80,
      "defeated": false,
      "position": [
        740,
        15
      ]
    },
    {
      "unique_name": "dragon_minion_2",
      "monster_type": "monster-static",
      "health": 8,
      "max_health": 8,
      "experience": 80,
      "defeated": false,
      "position": [
        760,
        10
      ]
    },
    {
      "unique_name": "dragon_minion_3",
      "monster_type": "monster-static",
      "health": 8,
      "max_health": 8,
      "experience": 80,
      "defeated": false,
      "position": [
        780,
        20
      ]
    },
    {
      "unique_name": "dragon_minion_4",
      "monster_type": "monster-static",
      "health": 7,
      "max_health": 7,
      "experience": 70,
      "defeated": false,
      "position": [
        750,
        5
      ]
    },
    {
      "unique_name": "ninja_dragon",
      "monster_type": "monster-dynamic",
      "health": 8,
      "max_health": 8,
      "experience": 85,
      "defeated": false,
      "position": [
        750,
        20
      ]
    },
    {
      "unique_name": "boss_dragon",
      "monster_type": "monster-boss",
      "health": 32,
      "max_health": 32,
      "experience": 400,
      "defeated": false,
      "position": [
        760,
        15
      ]
    },
    {
      "unique_name": "elite_guard_1",
      "monster_type": "monster-static",
      "health": 9,
      "max_health": 9,
      "experience": 90,
      "defeated": false,
      "position": [
        820,
        15
      ]
    },
    {
      "unique_name": "elite_guard_2",
      "monster_type": "monster-static",
      "health": 9,
      "max_health": 9,
      "experience": 90,
      "defeated": false,
      "position": [
        840,
        3
      ]
    },
    {
      "unique_name": "elite_guard_3",
      "monster_type": "monster-static",
      "health": 9,
      "max_health": 9,
      "experience": 90,
      "defeated": false,
      "position": [
        860,
        27
      ]
    },
    {
      "unique_name": "elite_guard_4",
      "monster_type": "monster-static",
      "health": 8,
      "max_health": 8,
      "experience": 80,
      "defeated": false,
      "position": [
        830,
        10
      ]
    },
    {
      "unique_name": "elite_guard_5",
      "monster_type": "monster-static",
      "health": 8,
      "max_health": 8,
      "experience": 80,
      "defeated": false,
      "position": [
        850,
        20
      ]
    },
    {
      "unique_name": "ninja_elite",
      "monster_type": "monster-dynamic",
      "health": 9,
      "max_health": 9,
      "experience": 95,
      "defeated": false,
      "position": [
        830,
        20
      ]
    },
    {
      "unique_name": "boss_elite",
      "monster_type": "monster-boss",
      "health": 36,
      "max_health": 36,
      "experience": 450,
      "defeated": false,
      "position": [
        840,
        15
      ]
    },
    {
      "unique_name": "final_room_goblin_guard",
      "monster_type": "monster-static",
      "health": 10,
      "max_health": 10,
      "experience": 100,
      "defeated": false,
      "position": [
        901,
        15
      ]
    },
    {
      "unique_name": "ninja_final",
      "monster_type": "monster-dynamic",
      "health": 10,
      "max_health": 10,
      "experience": 105,
      "defeated": false,
      "position": [
        920,
        15
      ]
    },
    {
      "unique_name": "boss_final",
      "monster_type": "monster-boss",
      "health": 40,
      "max_health": 40,
      "experience": 500,
      "defeated": false,
      "position": [
        950,
        15
      ]
    }
  ],
  "npcs": [
    {
      "unique_name": "intro_guide",
      "npc_type": "npc-static",
      "context": null,
      "response": "Skulls attack, Red Goblins obstruct.  Use the enter-key to fight them.  Diamonds Heal. Enemies get progressively harder.  You may have to outrun opponents to get to your goal.",
      "state_machine": "idle",
      "emoji": "\ud83d\udc64",
      "agenda": null,
      "conditions": [],
      "catch_message": "Not now",
      "conversation_history": [],
      "has_responded": false,
      "position": [
        7,
        15
      ]
    },
    {
      "unique_name": "ancient_wisdom_keeper",
      "npc_type": "npc-dynamic",
      "context": "You are the Ancient Wisdom Keeper, a powerful entity who has guarded the secrets of the dungeon for millennia. You have watched countless adventurers journey through the 12 chambers, facing goblins, orcs, shadow beasts, fire elementals, ice guardians, and dragon minions. You are wise, mysterious, and know the true purpose of this dungeon. You can answer questions about the journey, the monsters, the treasures, or the deeper meaning of the quest. Be enigmatic but helpful, and congratulate adventurers who have made it this far.",
      "response": "If I were connected to the LLM I could tell you anything, but the connection is down. All I can say is congratulations!",
      "state_machine": "idle",
      "emoji": "\ud83d\udc64",
      "agenda": null,
      "conditions": [],
      "catch_message": "Not now",
      "conversation_history": [],
      "has_responded": false,
      "position": [
        975,
        15
      ]
    }
  ],
  "variables": {},
  "quests": [
    {
      "id": "collection_quest",
      "conditions": [
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room1_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room1_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room2_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room2_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room3_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room3_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room4_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room4_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room5_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room5_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room6_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room6_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room7_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room7_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room8_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room8_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room9_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room9_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room10_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room10_2"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room11_1"
        },
        {
          "type": "has",
          "entity": "user",
          "value": "gem_room11_2"
        }
      ],
      "action": {
        "type": "command",
        "command": "level up",
        "target": null,
        "value": null
      },
      "status": "active",
      "completed": false
    },
    {
      "id": "wisdom_quest",
      "conditions": [
        {
          "type": "talked_to",
          "entity": "user",
          "value": "ancient_wisdom_keeper"
        }
      ],
      "action": {
        "type": "command",
        "command": "level up",
        "target": null,
        "value": null
      },
      "status": "active",
      "completed": false
    }
  ],
  "rules": [],
  "end_game": {
    "conditions": [
      {
        "condition": {
          "type": "responded_to",
          "entity": "ancient_wisdom_keeper"
        },
        "result": "win the game"
      }
    ],
    "win_message": "Congratulations! You have reached the Sanctuary of Wisdom and gained the knowledge of the Ancient Wisdom Keeper! Your journey through the 12 chambers is complete!",
    "lose_message": null
  },
  "on_game_start": {
    "title": "The Great Dungeon Journey!",
    "text_lines": [
      "Journey through 12 chambers from left to right",
      "Each room is guarded by monsters and contains treasures",
      "Reach the Sanctuary of Wisdom at the end to meet the Ancient Wisdom Keeper",
      "Commands: [arrow-keys] for movement, [Space] and [Enter] to talk/fight",
      "Use Shift+Arrow keys to pan the camera across the large world",
      "2025 Langjam"
    ],
    "links": [
      [
        "github",
        "https://github.com/mtshomskyieee/langjam-gamejam-2025"
      ]
    ]
  }
};

        // Game Engine
        class DungeonGame {
            constructor() {
                this.state = JSON.parse(JSON.stringify(INITIAL_GAME_STATE));
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.cellSize = 40;
                this.zoom = 1.0;
                this.viewportX = 0;
                this.viewportY = 0;
                this.panning = false;
                this.currentDialogNPC = null;
                this.interactionTexts = [];
                this.popupTexts = [];
                this.llmEndpoint = "http://localhost:1234/v1/chat/completions";
                this.llmToken = "anything";
                this.npcInteractionHistory = {};
                this.lastDialogOpenTime = 0;
                
                this.init();
                this.setupEventListeners();
                this.gameLoop();
            }
            
            init() {
                this.resizeCanvas();
                this.placeRandomEntities();
                this.centerOnUser();  // Center viewport on user at game start
                this.updateUI();
                this.showSplashScreen();
            }
            
            resizeCanvas() {
                const container = document.getElementById('game-container');
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
            }
            
            placeRandomEntities() {
                // Place random mythics
                for (let mythic of this.state.mythics) {
                    if (mythic.placement && mythic.placement.type === 'random') {
                        if (Math.random() * 100 < mythic.placement.percentage) {
                            mythic.position = [
                                Math.floor(Math.random() * this.state.world.width),
                                Math.floor(Math.random() * this.state.world.height)
                            ];
                        }
                    }
                }
                
                // Place random items
                for (let item of this.state.items) {
                    if (item.placement && item.placement.type === 'random') {
                        if (Math.random() * 100 < item.placement.percentage) {
                            item.position = [
                                Math.floor(Math.random() * this.state.world.width),
                                Math.floor(Math.random() * this.state.world.height)
                            ];
                        }
                    }
                }
                
                // Place random monsters
                for (let monster of this.state.monsters) {
                    if (monster.placement && monster.placement.type === 'random') {
                        if (Math.random() * 100 < monster.placement.percentage) {
                            monster.position = [
                                Math.floor(Math.random() * this.state.world.width),
                                Math.floor(Math.random() * this.state.world.height)
                            ];
                        }
                    }
                }
            }
            
            setupEventListeners() {
                // Movement
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'ArrowUp' && !e.shiftKey) {
                        this.moveUser(0, -1);
                    } else if (e.key === 'ArrowDown' && !e.shiftKey) {
                        this.moveUser(0, 1);
                    } else if (e.key === 'ArrowLeft' && !e.shiftKey) {
                        this.moveUser(-1, 0);
                    } else if (e.key === 'ArrowRight' && !e.shiftKey) {
                        this.moveUser(1, 0);
                    } else if (e.key === 'Enter' || e.key === ' ') {
                        this.handleEnterKey();
                    } else if (e.key === 'Escape') {
                        this.closeDialog();
                    } else if (e.key === '+' || e.key === '=') {
                        this.zoomIn();
                    } else if (e.key === '-') {
                        this.zoomOut();
                    }
                });
                
                // Panning
                let shiftPressed = false;
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Shift') shiftPressed = true;
                    if (shiftPressed && e.key.startsWith('Arrow')) {
                        this.panning = true;
                        if (e.key === 'ArrowUp') this.viewportY -= 5;
                        if (e.key === 'ArrowDown') this.viewportY += 5;
                        if (e.key === 'ArrowLeft') this.viewportX -= 5;
                        if (e.key === 'ArrowRight') this.viewportX += 5;
                    }
                });
                document.addEventListener('keyup', (e) => {
                    if (e.key === 'Shift') {
                        shiftPressed = false;
                        this.panning = false;
                        this.centerOnUser();
                    }
                });
            }
            
            moveUser(dx, dy) {
                const newX = this.state.user.position[0] + dx;
                const newY = this.state.user.position[1] + dy;
                
                // Check boundaries (allow 0 to width-1 and 0 to height-1)
                if (newX < 0 || newX >= this.state.world.width ||
                    newY < 0 || newY >= this.state.world.height) {
                    return;
                }
                
                // Check collisions
                if (!this.canMoveTo(newX, newY)) {
                    return;
                }
                
                this.state.user.position[0] = newX;
                this.state.user.position[1] = newY;
                
                // Check for item/mythic pickup
                this.checkPickups();
                
                // Check for interactions
                this.checkInteractions();
                
                // Update viewport
                if (!this.panning) {
                    this.centerOnUser();
                }
                
                // Evaluate rules and quests
                this.evaluateRules();
                this.evaluateQuests();
                this.checkEndGame();
                
                this.updateUI();
            }
            
            canMoveTo(x, y) {
                // Check furniture (walls, stone are impassible)
                for (let furniture of this.state.furniture) {
                    if (furniture.placement.type === 'coordinate') {
                        const pos = furniture.placement.coord;
                        if (pos[0] === x && pos[1] === y) {
                            // Check if furniture blocks movement (walls, stone do)
                            if (furniture.name === 'wall' || furniture.name === 'stone') {
                                return false;
                            }
                        }
                    } else if (furniture.placement.type === 'range') {
                        const coord1 = furniture.placement.coord1;
                        const coord2 = furniture.placement.coord2;
                        const minX = Math.min(coord1[0], coord2[0]);
                        const maxX = Math.max(coord1[0], coord2[0]);
                        const minY = Math.min(coord1[1], coord2[1]);
                        const maxY = Math.max(coord1[1], coord2[1]);
                        if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                            // Check if furniture blocks movement (walls, stone do)
                            if (furniture.name === 'wall' || furniture.name === 'stone') {
                                return false;
                            }
                        }
                    }
                }
                
                // Check NPCs
                for (let npc of this.state.npcs) {
                    if (npc.position && npc.position[0] === x && npc.position[1] === y) {
                        return false; // Can't walk through NPCs
                    }
                }
                
                // Check monsters
                for (let monster of this.state.monsters) {
                    if (!monster.defeated && monster.position && 
                        monster.position[0] === x && monster.position[1] === y) {
                        return false; // Can't walk through monsters
                    }
                }
                
                return true;
            }
            
            checkPickups() {
                const userPos = this.state.user.position;
                let pickedUpSomething = false;
                
                // Check mythics
                for (let mythic of this.state.mythics) {
                    if (!mythic.picked_up && mythic.position &&
                        mythic.position[0] === userPos[0] && mythic.position[1] === userPos[1]) {
                        if (mythic.can_pickup) {
                            this.state.user.inventory.push(mythic.unique_name);
                            mythic.picked_up = true;
                            pickedUpSomething = true;
                            this.showInteractionText(userPos[0], userPos[1], `Picked up ${mythic.unique_name}`);
                        } else {
                            this.showInteractionText(userPos[0], userPos[1], mythic.catch_message);
                        }
                    }
                }
                
                // Check items
                for (let item of this.state.items) {
                    if (!item.picked_up && item.position &&
                        item.position[0] === userPos[0] && item.position[1] === userPos[1]) {
                        if (item.can_pickup) {
                            this.state.user.inventory.push(item.unique_name);
                            item.picked_up = true;
                            pickedUpSomething = true;
                            
                            // Heal 25% if it's a healing item
                            if (item.item_type === 'item-heal') {
                                const maxHealth = 100;
                                const healAmount = Math.floor(maxHealth * 0.25); // 25% of max health
                                const oldHealth = this.state.user.health;
                                this.state.user.health = Math.min(maxHealth, this.state.user.health + healAmount);
                                const actualHeal = this.state.user.health - oldHealth;
                                
                                if (actualHeal > 0) {
                                    this.showInteractionText(userPos[0], userPos[1], `Picked up ${item.unique_name}! Healed ${actualHeal} health!`);
                                } else {
                                    this.showInteractionText(userPos[0], userPos[1], `Picked up ${item.unique_name}! (Already at full health)`);
                                }
                            } else {
                                this.showInteractionText(userPos[0], userPos[1], `Picked up ${item.unique_name}`);
                            }
                        } else {
                            this.showInteractionText(userPos[0], userPos[1], item.catch_message);
                        }
                    }
                }
                
                // If we picked something up, check end game conditions
                if (pickedUpSomething) {
                    this.checkEndGame();
                }
            }
            
            checkInteractions() {
                const userPos = this.state.user.position;
                
                // Check NPCs at same position
                for (let npc of this.state.npcs) {
                    if (npc.position && npc.position[0] === userPos[0] && npc.position[1] === userPos[1]) {
                        // Auto-trigger interaction based on rules
                        // For now, just mark as available for interaction
                    }
                }
            }
            
            handleEnterKey() {
                const userPos = this.state.user.position;
                
                // Check for monsters at same position or adjacent (combat)
                for (let monster of this.state.monsters) {
                    if (!monster.defeated && monster.position) {
                        const dx = Math.abs(monster.position[0] - userPos[0]);
                        const dy = Math.abs(monster.position[1] - userPos[1]);
                        // Attack if on same cell or adjacent (distance <= 1)
                        if (dx <= 1 && dy <= 1 && (dx + dy) <= 1) {
                            this.attackMonster(monster);
                            return;
                        }
                    }
                }
                
                // Check for NPCs at same position or adjacent
                // Don't interact if dialog is already open
                const panel = document.getElementById('dialog-panel');
                if (panel && panel.classList.contains('show')) {
                    return; // Dialog already open, don't trigger new interaction
                }
                
                for (let npc of this.state.npcs) {
                    if (npc.position) {
                        const dx = Math.abs(npc.position[0] - userPos[0]);
                        const dy = Math.abs(npc.position[1] - userPos[1]);
                        // Interact if on same cell or adjacent (distance <= 1)
                        if (dx <= 1 && dy <= 1 && (dx + dy) <= 1) {
                            this.interactWithNPC(npc);
                            return;
                        }
                    }
                }
            }
            
            attackMonster(monster) {
                // Default punch attack does 1 damage
                let damage = 1;
                let weaponUsed = 'punch';
                
                // Check if user has items that can be used as weapons
                // For now, use default punch attack
                // TODO: Support "attack <monster> with <item>" command
                
                // Show health bars for combat
                monster.showHealthBar = true;
                this.state.user.showHealthBar = true;
                
                // Set timeout to hide health bars after 3 seconds
                if (monster.healthBarTimeout) {
                    clearTimeout(monster.healthBarTimeout);
                }
                if (this.state.user.healthBarTimeout) {
                    clearTimeout(this.state.user.healthBarTimeout);
                }
                monster.healthBarTimeout = setTimeout(() => {
                    monster.showHealthBar = false;
                }, 3000);
                this.state.user.healthBarTimeout = setTimeout(() => {
                    this.state.user.showHealthBar = false;
                }, 3000);
                
                // Apply damage
                monster.health -= damage;
                
                // Check if monster is defeated
                if (monster.health <= 0) {
                    monster.defeated = true;
                    const expGained = monster.experience || 0;
                    this.state.user.experience += expGained;
                    
                    this.showInteractionText(
                        monster.position[0],
                        monster.position[1],
                        `You defeated ${monster.unique_name}! Gained ${expGained} experience!`
                    );
                    
                    // Remove monster from blocking position
                    monster.position = null;
                    monster.showHealthBar = false;
                    if (monster.healthBarTimeout) {
                        clearTimeout(monster.healthBarTimeout);
                    }
                } else {
                    // Monster counter-attacks (2 damage for boss, 1 for others)
                    const counterDamage = monster.monster_type === 'monster-boss' ? 2 : 1;
                    this.state.user.health -= counterDamage;
                    
                    // Check if user is defeated
                    if (this.state.user.health <= 0) {
                        this.checkEndGame(); // This will trigger lose condition if health <= 0
                    }
                }
                
                this.updateUI();
                this.checkEndGame();
            }
            
            interactWithNPC(npc) {
                const panel = document.getElementById('dialog-panel');
                
                // If dialog is already open for this NPC, don't reopen it
                if (this.currentDialogNPC && this.currentDialogNPC.unique_name === npc.unique_name && panel.classList.contains('show')) {
                    return;
                }
                
                // Track that user talked to this NPC
                if (!this.state.user.talked_to_npcs.includes(npc.unique_name)) {
                    this.state.user.talked_to_npcs.push(npc.unique_name);
                    // Evaluate quests after talking to NPC (in case a quest requires talking to NPC)
                    this.evaluateQuests();
                }
                
                this.currentDialogNPC = npc;
                panel.classList.add('show');
                this.lastDialogOpenTime = Date.now();
                
                if (npc.npc_type === 'npc-static') {
                    this.showStaticNPCDialog(npc);
                } else if (npc.npc_type === 'npc-dynamic') {
                    this.showDynamicNPCDialog(npc);
                } else if (npc.npc_type === 'npc-state-machine') {
                    this.showStateMachineNPCDialog(npc);
                }
            }
            
            showStaticNPCDialog(npc) {
                const content = document.getElementById('dialog-content');
                const input = document.getElementById('dialog-input');
                input.style.display = 'none';
                
                // Check conditions
                let response = npc.response;
                for (let condition of npc.conditions) {
                    if (this.checkNPCCondition(condition)) {
                        if (condition.then_action === 'response') {
                            response = condition.action_value;
                            break;
                        }
                    }
                }
                
                // If response contains "|", randomly select one phrase
                if (response && response.includes('|')) {
                    const phrases = response.split('|').map(p => p.trim()).filter(p => p.length > 0);
                    if (phrases.length > 0) {
                        response = phrases[Math.floor(Math.random() * phrases.length)];
                    }
                }
                
                content.innerHTML = `<h3>${npc.unique_name}</h3><p>${response}</p>`;
            }
            
            showDynamicNPCDialog(npc) {
                const content = document.getElementById('dialog-content');
                const input = document.getElementById('dialog-input');
                input.style.display = 'block';
                input.focus();
                
                if (!this.npcInteractionHistory[npc.unique_name]) {
                    this.npcInteractionHistory[npc.unique_name] = [];
                }
                
                let contextText = npc.context || '';
                if (npc.agenda) {
                    contextText += '\nAgenda: ' + npc.agenda;
                }
                
                // Show static response as initial message if available
                let initialMessage = '';
                if (npc.response) {
                    initialMessage = `<p><strong>${npc.unique_name}:</strong> ${npc.response}</p>`;
                }
                
                content.innerHTML = `<h3>${npc.unique_name}</h3><div id="conversation">${initialMessage}</div>`;
            }
            
            showStateMachineNPCDialog(npc) {
                const content = document.getElementById('dialog-content');
                const input = document.getElementById('dialog-input');
                input.style.display = 'none';
                
                // Simple state machine - use state to determine response
                let response = npc.response || 'Hello!';
                if (npc.state_machine === 'idle') {
                    response = 'I am idle.';
                }
                
                content.innerHTML = `<h3>${npc.unique_name}</h3><p>${response}</p>`;
            }
            
            handleDialogInput(message) {
                if (!this.currentDialogNPC || this.currentDialogNPC.npc_type !== 'npc-dynamic') {
                    return;
                }
                
                const npc = this.currentDialogNPC;
                const conversationDiv = document.getElementById('conversation');
                
                // Add user message
                conversationDiv.innerHTML += `<p><strong>You:</strong> ${message}</p>`;
                
                // Send to LLM (if configured)
                if (this.llmEndpoint && this.llmToken) {
                    this.sendToLLM(npc, message, conversationDiv);
                } else {
                    // Use static response as fallback if available
                    let fallbackResponse = npc.response || "I'm having trouble thinking right now. Can we talk later?";
                    conversationDiv.innerHTML += `<p><strong>${npc.unique_name}:</strong> ${fallbackResponse}</p>`;
                    // Mark that NPC has responded (even if LLM not configured)
                    npc.has_responded = true;
                    // Evaluate quests and check end game after NPC responds
                    this.evaluateQuests();
                    this.checkEndGame();
                }
            }
            
            async sendToLLM(npc, message, conversationDiv) {
                try {
                    const history = this.npcInteractionHistory[npc.unique_name] || [];
                    history.push({role: 'user', content: message});
                    
                    // Check if endpoint is localhost and we're running from file://
                    const isLocalhost = this.llmEndpoint && (this.llmEndpoint.includes('localhost') || this.llmEndpoint.includes('127.0.0.1'));
                    const isFileProtocol = window.location.protocol === 'file:';
                    
                    if (isLocalhost && isFileProtocol) {
                        // Use static response as fallback if available
                        if (npc.response) {
                            conversationDiv.innerHTML += `<p><strong>${npc.unique_name}:</strong> ${npc.response}</p>`;
                            npc.has_responded = true;
                            this.evaluateQuests();
                            this.checkEndGame();
                        } else {
                            conversationDiv.innerHTML += `<p><strong>${npc.unique_name}:</strong> <em>Note: To use localhost LLM, please serve this HTML file from a local web server (e.g., python -m http.server) instead of opening it directly. CORS policy blocks file:// requests to localhost.</em></p>`;
                        }
                        return;
                    }
                    
                    const fetchOptions = {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${this.llmToken}`
                        },
                        body: JSON.stringify({
                            messages: [
                                {role: 'system', content: npc.context || '' + (npc.agenda ? '\nAgenda: ' + npc.agenda : '')},
                                ...history.slice(-10) // Last 10 messages
                            ]
                        })
                    };
                    
                    // For localhost endpoints, explicitly set mode
                    if (isLocalhost) {
                        fetchOptions.mode = 'cors';
                    }
                    
                    const response = await fetch(this.llmEndpoint, fetchOptions);
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    const llmResponse = data.choices?.[0]?.message?.content || "I'm having trouble thinking right now.";
                    
                    history.push({role: 'assistant', content: llmResponse});
                    conversationDiv.innerHTML += `<p><strong>${npc.unique_name}:</strong> ${llmResponse}</p>`;
                    
                    // Mark that NPC has responded
                    npc.has_responded = true;
                    // Evaluate quests and check end game after NPC responds
                    this.evaluateQuests();
                    this.checkEndGame();
                } catch (error) {
                    console.error('LLM request error:', error);
                    
                    // Use static response as fallback if available
                    if (npc.response) {
                        conversationDiv.innerHTML += `<p><strong>${npc.unique_name}:</strong> ${npc.response}</p>`;
                        npc.has_responded = true;
                        this.evaluateQuests();
                        this.checkEndGame();
                        return;
                    }
                    
                    // Otherwise show error message
                    let errorMsg = "I'm having trouble thinking right now. Can we talk later?";
                    
                    const errorStr = error.toString();
                    if (errorStr.includes('CORS') || errorStr.includes('preflight')) {
                        errorMsg = `CORS Error: The LLM server at ${this.llmEndpoint} needs to allow CORS from ${window.location.origin}. The server must respond to OPTIONS requests with these headers: Access-Control-Allow-Origin: ${window.location.origin}, Access-Control-Allow-Methods: POST, Access-Control-Allow-Headers: Content-Type, Authorization. Please configure your LLM server to allow CORS.`;
                    } else if (errorStr.includes('Failed to fetch') || errorStr.includes('ERR_FAILED')) {
                        errorMsg = `Connection Error: Could not connect to LLM server at ${this.llmEndpoint}. Please ensure: 1) The server is running, 2) The URL is correct, 3) The server allows CORS from ${window.location.origin}`;
                    } else if (error.message) {
                        errorMsg = `Error: ${error.message}`;
                    }
                    
                    conversationDiv.innerHTML += `<p><strong>${npc.unique_name}:</strong> <em style="color: #ff6b6b;">${errorMsg}</em></p>`;
                    
                    // Mark that NPC has responded (even on error)
                    npc.has_responded = true;
                    // Evaluate quests and check end game after NPC responds
                    this.evaluateQuests();
                    this.checkEndGame();
                }
            }
            
            checkNPCCondition(condition) {
                if (condition.condition_type === 'item') {
                    return this.state.user.inventory.includes(condition.value);
                } else if (condition.condition_type === 'experience') {
                    return this.compareValues(this.state.user.experience, condition.operator, condition.value);
                } else if (condition.condition_type === 'health') {
                    return this.compareValues(this.state.user.health, condition.operator, condition.value);
                }
                return false;
            }
            
            closeDialog() {
                // Prevent closing if dialog was just opened (within last 200ms)
                // This prevents accidental closes from key repeat or rapid key presses
                const timeSinceOpen = Date.now() - this.lastDialogOpenTime;
                if (timeSinceOpen < 200) {
                    return;
                }
                
                const panel = document.getElementById('dialog-panel');
                if (panel) {
                    panel.classList.remove('show');
                }
                this.currentDialogNPC = null;
                this.lastDialogOpenTime = 0;
                // Clear dialog content to ensure clean state
                const content = document.getElementById('dialog-content');
                if (content) {
                    content.innerHTML = '';
                }
                const input = document.getElementById('dialog-input');
                if (input) {
                    input.style.display = 'none';
                    input.value = '';
                }
            }
            
            compareValues(a, op, b) {
                switch(op) {
                    case '>': return a > b;
                    case '<': return a < b;
                    case '>=': return a >= b;
                    case '<=': return a <= b;
                    case '==': return a == b;
                    case '!=': return a != b;
                    default: return a == b;
                }
            }
            
            evaluateRules() {
                for (let rule of this.state.rules) {
                    if (this.checkConditions(rule.conditions)) {
                        this.executeAction(rule.action);
                    }
                }
            }
            
            evaluateQuests() {
                for (let quest of this.state.quests) {
                    if (!quest.completed && this.checkConditions(quest.conditions)) {
                        this.executeAction(quest.action);
                        quest.completed = true;
                        quest.status = 'completed';
                        // Check end game after quest completion (in case quest and end_game share conditions)
                        this.checkEndGame();
                    }
                }
            }
            
            checkConditions(conditions) {
                for (let condition of conditions) {
                    if (!this.checkCondition(condition)) {
                        return false;
                    }
                }
                return true;
            }
            
            checkCondition(condition) {
                if (condition.type === 'position') {
                    const entity = this.getEntity(condition.entity);
                    if (!entity || !entity.position) return false;
                    return entity.position[0] === condition.position[0] &&
                           entity.position[1] === condition.position[1];
                } else if (condition.type === 'has') {
                    if (condition.entity === 'user') {
                        if (typeof condition.value === 'string') {
                            return this.state.user.inventory.includes(condition.value);
                        }
                    }
                } else if (condition.type === 'talked_to') {
                    if (condition.entity === 'user') {
                        return this.state.user.talked_to_npcs.includes(condition.value);
                    }
                } else if (condition.type === 'responded_to') {
                    // Check if the NPC (condition.entity is the NPC name) has responded
                    const npc = this.getEntity(condition.entity);
                    return npc && npc.has_responded === true;
                } else if (condition.type === 'comparison') {
                    const entity = this.getEntity(condition.entity);
                    if (!entity) return false;
                    const attr = condition.value; // This should be the attribute name
                    const value = entity[attr] || 0;
                    return this.compareValues(value, condition.operator, condition.value);
                }
                return false;
            }
            
            getEntity(name) {
                if (name === 'user') return this.state.user;
                for (let npc of this.state.npcs) {
                    if (npc.unique_name === name) return npc;
                }
                for (let monster of this.state.monsters) {
                    if (monster.unique_name === name) return monster;
                }
                for (let item of this.state.items) {
                    if (item.unique_name === name) return item;
                }
                for (let mythic of this.state.mythics) {
                    if (mythic.unique_name === name) return mythic;
                }
                return null;
            }
            
            executeAction(action) {
                if (action.type === 'level up') {
                    this.state.user.level += 1;
                    this.showInteractionText(
                        this.state.user.position[0],
                        this.state.user.position[1],
                        'Level Up!'
                    );
                } else if (action.type === 'talk') {
                    // Talk action - handled by interactions
                }
            }
            
            checkEndGame() {
                // Check if user is dead (health <= 0)
                if (this.state.user.health <= 0) {
                    // Check for lose condition
                    if (this.state.end_game && this.state.end_game.conditions) {
                        for (let endCondition of this.state.end_game.conditions) {
                            if (endCondition.result === 'die and lose the game') {
                                this.endGame(false);
                                return;
                            }
                        }
                    }
                    // Default lose message if no specific condition
                    this.endGame(false);
                    return;
                }
                
                if (!this.state.end_game || !this.state.end_game.conditions) return;
                
                // Group conditions by result type
                const winConditions = [];
                const loseConditions = [];
                
                for (let endCondition of this.state.end_game.conditions) {
                    if (endCondition.result === 'win the game') {
                        winConditions.push(endCondition.condition);
                    } else if (endCondition.result === 'die and lose the game') {
                        loseConditions.push(endCondition.condition);
                    }
                }
                
                // Check win conditions (ALL must be true - this handles AND conditions)
                if (winConditions.length > 0) {
                    let allWinConditionsMet = true;
                    for (let condition of winConditions) {
                        if (!this.checkCondition(condition)) {
                            allWinConditionsMet = false;
                            break;
                        }
                    }
                    if (allWinConditionsMet) {
                        this.endGame(true);
                        return;
                    }
                }
                
                // Check lose conditions (all must be true)
                if (loseConditions.length > 0) {
                    let allLoseConditionsMet = true;
                    for (let condition of loseConditions) {
                        if (!this.checkCondition(condition)) {
                            allLoseConditionsMet = false;
                            break;
                        }
                    }
                    if (allLoseConditionsMet) {
                        this.endGame(false);
                        return;
                    }
                }
            }
            
            endGame(won) {
                const message = won ? 
                    (this.state.end_game.win_message || 'You won!') :
                    (this.state.end_game.lose_message || 'You lost!');
                alert(message);
            }
            
            centerOnUser() {
                // Ensure viewport stays within bounds
                this.viewportX = Math.max(0, Math.min(this.state.user.position[0], this.state.world.width - 1));
                this.viewportY = Math.max(0, Math.min(this.state.user.position[1], this.state.world.height - 1));
            }
            
            zoomIn() {
                this.zoom = Math.min(this.zoom * 1.2, 3.0);
            }
            
            zoomOut() {
                this.zoom = Math.max(this.zoom / 1.2, 0.5);
            }
            
            showInteractionText(x, y, text) {
                const textObj = {
                    x: x,
                    y: y,
                    text: text,
                    time: Date.now()
                };
                this.interactionTexts.push(textObj);
                setTimeout(() => {
                    const index = this.interactionTexts.indexOf(textObj);
                    if (index > -1) this.interactionTexts.splice(index, 1);
                }, 2000);
            }
            
            updateUI() {
                // Update status
                const statusContent = document.getElementById('status-content');
                statusContent.innerHTML = `
                    <div>Health: ${this.state.user.health}</div>
                    <div>Experience: ${this.state.user.experience}</div>
                    <div>Level: ${this.state.user.level}</div>
                    <div>Position: (${this.state.user.position[0]}, ${this.state.user.position[1]})</div>
                `;
                
                // Update inventory
                const inventoryContent = document.getElementById('inventory-content');
                if (this.state.user.inventory.length === 0) {
                    inventoryContent.innerHTML = '<div>Inventory is empty</div>';
                } else {
                    inventoryContent.innerHTML = this.state.user.inventory.map(item => 
                        `<div>${item}</div>`
                    ).join('');
                }
                
                // Update quests
                const questContent = document.getElementById('quest-content');
                if (this.state.quests.length === 0) {
                    questContent.innerHTML = '<div>No quests</div>';
                } else {
                    questContent.innerHTML = this.state.quests.map(quest => 
                        `<div><strong>Quest ${quest.id}</strong>: ${quest.status}</div>`
                    ).join('<hr>');
                }
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                const cellSize = this.cellSize * this.zoom;
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                
                // Calculate visible grid
                const viewWidth = Math.ceil(this.canvas.width / cellSize) + 2;
                const viewHeight = Math.ceil(this.canvas.height / cellSize) + 2;
                const startX = Math.max(0, Math.floor(this.viewportX - viewWidth / 2));
                const startY = Math.max(0, Math.floor(this.viewportY - viewHeight / 2));
                const endX = Math.min(this.state.world.width, startX + viewWidth);
                const endY = Math.min(this.state.world.height, startY + viewHeight);
                
                // Draw terrain (grass by default)
                this.ctx.fillStyle = '#4a7c59';
                for (let y = startY; y < endY; y++) {
                    for (let x = startX; x < endX; x++) {
                        const screenX = centerX + (x - this.viewportX) * cellSize;
                        const screenY = centerY + (y - this.viewportY) * cellSize;
                        this.ctx.fillRect(screenX, screenY, cellSize, cellSize);
                    }
                }
                
                // Draw furniture
                for (let furniture of this.state.furniture) {
                    let positions = [];
                    if (furniture.placement.type === 'coordinate') {
                        positions = [furniture.placement.coord];
                    } else if (furniture.placement.type === 'range') {
                        const coord1 = furniture.placement.coord1;
                        const coord2 = furniture.placement.coord2;
                        const minX = Math.min(coord1[0], coord2[0]);
                        const maxX = Math.max(coord1[0], coord2[0]);
                        const minY = Math.min(coord1[1], coord2[1]);
                        const maxY = Math.max(coord1[1], coord2[1]);
                        for (let fx = minX; fx <= maxX; fx++) {
                            for (let fy = minY; fy <= maxY; fy++) {
                                positions.push([fx, fy]);
                            }
                        }
                    }
                    
                    // Choose emoji based on furniture name
                    let emoji = 'ðŸ '; // default
                    if (furniture.name === 'wall' || furniture.name === 'stone') {
                        emoji = 'ðŸ§±';
                    } else if (furniture.name === 'grass') {
                        emoji = 'ðŸŸ©';
                    }
                    
                    for (let pos of positions) {
                        const screenX = centerX + (pos[0] - this.viewportX) * cellSize;
                        const screenY = centerY + (pos[1] - this.viewportY) * cellSize;
                        if (screenX >= -cellSize && screenX <= this.canvas.width + cellSize &&
                            screenY >= -cellSize && screenY <= this.canvas.height + cellSize) {
                            this.ctx.font = `${cellSize * 0.8}px Arial`;
                            this.ctx.fillText(emoji, screenX, screenY + cellSize * 0.8);
                        }
                    }
                }
                
                // Draw items
                for (let item of this.state.items) {
                    if (!item.picked_up && item.position) {
                        const screenX = centerX + (item.position[0] - this.viewportX) * cellSize;
                        const screenY = centerY + (item.position[1] - this.viewportY) * cellSize;
                        if (screenX >= -cellSize && screenX <= this.canvas.width + cellSize &&
                            screenY >= -cellSize && screenY <= this.canvas.height + cellSize) {
                            this.ctx.font = `${cellSize * 0.8}px Arial`;
                            this.ctx.fillText('ðŸ’Ž', screenX, screenY + cellSize * 0.8);
                        }
                    }
                }
                
                // Draw mythics
                for (let mythic of this.state.mythics) {
                    if (!mythic.picked_up && mythic.position) {
                        const screenX = centerX + (mythic.position[0] - this.viewportX) * cellSize;
                        const screenY = centerY + (mythic.position[1] - this.viewportY) * cellSize;
                        if (screenX >= -cellSize && screenX <= this.canvas.width + cellSize &&
                            screenY >= -cellSize && screenY <= this.canvas.height + cellSize) {
                            this.ctx.font = `${cellSize * 0.8}px Arial`;
                            this.ctx.fillText('ðŸ’ ', screenX, screenY + cellSize * 0.8);
                        }
                    }
                }
                
                // Draw monsters
                for (let monster of this.state.monsters) {
                    if (!monster.defeated && monster.position) {
                        const screenX = centerX + (monster.position[0] - this.viewportX) * cellSize;
                        const screenY = centerY + (monster.position[1] - this.viewportY) * cellSize;
                        if (screenX >= -cellSize && screenX <= this.canvas.width + cellSize &&
                            screenY >= -cellSize && screenY <= this.canvas.height + cellSize) {
                            // Boss monsters are 4x bigger
                            const isBoss = monster.monster_type === 'monster-boss';
                            const fontSize = isBoss ? cellSize * 3.2 : cellSize * 0.8; // 4x bigger = 3.2x font size (0.8 * 4)
                            this.ctx.font = `${fontSize}px Arial`;
                            
                            // Use skull emoji for dynamic/boss monsters, ogre emoji for static monsters
                            const emoji = (monster.monster_type === 'monster-dynamic' || monster.monster_type === 'monster-boss') ? 'ðŸ’€' : 'ðŸ‘¹';
                            const yOffset = isBoss ? cellSize * 3.2 : cellSize * 0.8;
                            this.ctx.fillText(emoji, screenX, screenY + yOffset);
                            
                            // Draw health bar if monster is in combat
                            if (monster.showHealthBar) {
                                const barY = isBoss ? screenY - 40 : screenY - 10;
                                const barSize = isBoss ? cellSize * 4 : cellSize;
                                this.drawHealthBar(screenX, barY, monster.health, monster.max_health, barSize);
                            }
                        }
                    }
                }
                
                // Draw NPCs
                for (let npc of this.state.npcs) {
                    if (npc.position) {
                        const screenX = centerX + (npc.position[0] - this.viewportX) * cellSize;
                        const screenY = centerY + (npc.position[1] - this.viewportY) * cellSize;
                        if (screenX >= -cellSize && screenX <= this.canvas.width + cellSize &&
                            screenY >= -cellSize && screenY <= this.canvas.height + cellSize) {
                            this.ctx.font = `${cellSize * 0.8}px Arial`;
                            this.ctx.fillText(npc.emoji, screenX, screenY + cellSize * 0.8);
                        }
                    }
                }
                
                // Draw user
                const userScreenX = centerX + (this.state.user.position[0] - this.viewportX) * cellSize;
                const userScreenY = centerY + (this.state.user.position[1] - this.viewportY) * cellSize;
                this.ctx.font = `${cellSize * 0.8}px Arial`;
                this.ctx.fillText('ðŸ§™', userScreenX, userScreenY + cellSize * 0.8);
                
                // Draw health bar if user is in combat
                if (this.state.user.showHealthBar) {
                    this.drawHealthBar(userScreenX, userScreenY - 10, this.state.user.health, 100, cellSize);
                }
                
                // Draw interaction texts
                for (let textObj of this.interactionTexts) {
                    const screenX = centerX + (textObj.x - this.viewportX) * cellSize;
                    const screenY = centerY + (textObj.y - this.viewportY) * cellSize - 20;
                    this.ctx.fillStyle = '#fff';
                    this.ctx.font = '12px Arial';
                    this.ctx.fillText(textObj.text, screenX, screenY);
                    this.ctx.fillStyle = '#000';
                }
            }
            
            drawHealthBar(x, y, currentHealth, maxHealth, cellSize) {
                const barWidth = cellSize * 0.8;
                const barHeight = 6;
                const healthPercent = Math.max(0, Math.min(1, currentHealth / maxHealth));
                
                // Draw background (red/dark)
                this.ctx.fillStyle = '#333';
                this.ctx.fillRect(x - barWidth / 2, y, barWidth, barHeight);
                
                // Draw health (green to red gradient)
                if (healthPercent > 0.5) {
                    this.ctx.fillStyle = '#0f0'; // Green
                } else if (healthPercent > 0.25) {
                    this.ctx.fillStyle = '#ff0'; // Yellow
                } else {
                    this.ctx.fillStyle = '#f00'; // Red
                }
                this.ctx.fillRect(x - barWidth / 2, y, barWidth * healthPercent, barHeight);
                
                // Draw border
                this.ctx.strokeStyle = '#fff';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(x - barWidth / 2, y, barWidth, barHeight);
            }
            
            gameLoop() {
                this.updateDynamicMonsters();
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
            
            updateDynamicMonsters() {
                // Update dynamic monsters to chase the hero if within 10 units
                const heroPos = this.state.user.position;
                const currentTime = Date.now();
                
                for (let monster of this.state.monsters) {
                    if ((monster.monster_type === 'monster-dynamic' || monster.monster_type === 'monster-boss') && !monster.defeated && monster.position) {
                        const dx = heroPos[0] - monster.position[0];
                        const dy = heroPos[1] - monster.position[1];
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        // Check if monster is adjacent to player (distance <= 1 for adjacent cells)
                        const isAdjacent = Math.abs(dx) <= 1 && Math.abs(dy) <= 1 && (Math.abs(dx) + Math.abs(dy)) <= 1;
                        
                        // Attack player if adjacent and cooldown has passed (3 seconds = 3000ms)
                        if (isAdjacent) {
                            // Initialize lastAttackTime if not set
                            if (!monster.lastAttackTime) {
                                monster.lastAttackTime = 0;
                            }
                            
                            // Attack if 3 seconds (3000ms) have passed since last attack
                            if (currentTime - monster.lastAttackTime >= 3000) {
                                monster.lastAttackTime = currentTime;
                                
                                // Show health bars for combat
                                monster.showHealthBar = true;
                                this.state.user.showHealthBar = true;
                                
                                // Set timeout to hide health bars after 3 seconds
                                if (monster.healthBarTimeout) {
                                    clearTimeout(monster.healthBarTimeout);
                                }
                                if (this.state.user.healthBarTimeout) {
                                    clearTimeout(this.state.user.healthBarTimeout);
                                }
                                monster.healthBarTimeout = setTimeout(() => {
                                    monster.showHealthBar = false;
                                }, 3000);
                                this.state.user.healthBarTimeout = setTimeout(() => {
                                    this.state.user.showHealthBar = false;
                                }, 3000);
                                
                                // Deal damage to player (2 for boss, 1 for dynamic)
                                const damage = monster.monster_type === 'monster-boss' ? 2 : 1;
                                this.state.user.health -= damage;
                                
                                // Check if user is defeated
                                if (this.state.user.health <= 0) {
                                    this.checkEndGame(); // This will trigger lose condition if health <= 0
                                }
                                
                                this.updateUI();
                            }
                        }
                        // If hero is within 10 units but not adjacent, move towards hero slowly
                        else if (distance <= 10 && distance > 0) {
                            // Calculate direction (normalized)
                            const dirX = dx / distance;
                            const dirY = dy / distance;
                            
                            // Move slowly (0.1 units per frame, but we'll move in discrete steps)
                            // Use a counter to slow down movement
                            if (!monster.moveCounter) {
                                monster.moveCounter = 0;
                            }
                            monster.moveCounter++;
                            
                            // Move every 10 frames (adjust for speed)
                            if (monster.moveCounter >= 10) {
                                monster.moveCounter = 0;
                                
                                // Calculate new position (move 1 unit towards hero)
                                let newX = monster.position[0];
                                let newY = monster.position[1];
                                
                                // Move in the direction of the hero (discrete movement)
                                if (Math.abs(dirX) > Math.abs(dirY)) {
                                    newX += dirX > 0 ? 1 : -1;
                                } else {
                                    newY += dirY > 0 ? 1 : -1;
                                }
                                
                                // Check if the new position is valid (not blocked)
                                if (this.canMonsterMoveTo(newX, newY)) {
                                    monster.position[0] = newX;
                                    monster.position[1] = newY;
                                }
                            }
                        }
                    }
                }
            }
            
            canMonsterMoveTo(x, y) {
                // Check boundaries
                if (x < 0 || x >= this.state.world.width ||
                    y < 0 || y >= this.state.world.height) {
                    return false;
                }
                
                // Check furniture (walls, stone are impassible)
                for (let furniture of this.state.furniture) {
                    if (furniture.placement.type === 'coordinate') {
                        const pos = furniture.placement.coord;
                        if (pos[0] === x && pos[1] === y) {
                            if (furniture.name === 'wall' || furniture.name === 'stone') {
                                return false;
                            }
                        }
                    } else if (furniture.placement.type === 'range') {
                        const coord1 = furniture.placement.coord1;
                        const coord2 = furniture.placement.coord2;
                        const minX = Math.min(coord1[0], coord2[0]);
                        const maxX = Math.max(coord1[0], coord2[0]);
                        const minY = Math.min(coord1[1], coord2[1]);
                        const maxY = Math.max(coord1[1], coord2[1]);
                        if (x >= minX && x <= maxX && y >= minY && y <= maxY) {
                            if (furniture.name === 'wall' || furniture.name === 'stone') {
                                return false;
                            }
                        }
                    }
                }
                
                // Don't check collisions with other monsters/NPCs for now (monsters can overlap)
                // But don't move into the hero's position
                if (this.state.user.position[0] === x && this.state.user.position[1] === y) {
                    return false;
                }
                
                return true;
            }
            
            saveGame() {
                const saveData = {
                    version: '1.0',
                    timestamp: new Date().toISOString(),
                    game_state: this.state
                };
                const blob = new Blob([JSON.stringify(saveData, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'game_save.json';
                a.click();
                URL.revokeObjectURL(url);
            }
            
            loadGame(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const saveData = JSON.parse(e.target.result);
                        this.state = saveData.game_state;
                        this.updateUI();
                        alert('Game loaded successfully');
                    } catch (error) {
                        alert('Failed to load game: ' + error.message);
                    }
                };
                reader.readAsText(file);
            }
            
            showSplashScreen() {
                if (!this.state.on_game_start || !this.state.on_game_start.title) {
                    return; // No splash screen configured
                }
                
                const splashScreen = document.getElementById('splash-screen');
                const splashTitle = document.getElementById('splash-title');
                const splashText = document.getElementById('splash-text');
                
                if (splashScreen && splashTitle && splashText) {
                    splashTitle.textContent = this.state.on_game_start.title;
                    
                    // Clear existing text
                    splashText.innerHTML = '';
                    
                    // Add each text line as a paragraph
                    if (this.state.on_game_start.text_lines && this.state.on_game_start.text_lines.length > 0) {
                        this.state.on_game_start.text_lines.forEach(text => {
                            const p = document.createElement('p');
                            p.textContent = text;
                            splashText.appendChild(p);
                        });
                    }
                    
                    // Add links
                    if (this.state.on_game_start.links && this.state.on_game_start.links.length > 0) {
                        const linksDiv = document.createElement('div');
                        linksDiv.style.marginTop = '20px';
                        linksDiv.style.display = 'flex';
                        linksDiv.style.flexWrap = 'wrap';
                        linksDiv.style.gap = '15px';
                        linksDiv.style.justifyContent = 'center';
                        
                        this.state.on_game_start.links.forEach(link => {
                            const [anchorText, url] = link;
                            const a = document.createElement('a');
                            a.href = url;
                            a.textContent = anchorText;
                            a.target = '_blank';
                            a.rel = 'noopener noreferrer';
                            a.style.color = '#ffd700';
                            a.style.textDecoration = 'none';
                            a.style.padding = '8px 16px';
                            a.style.border = '2px solid #ffd700';
                            a.style.borderRadius = '5px';
                            a.style.transition = 'all 0.3s';
                            a.style.display = 'inline-block';
                            a.onmouseenter = function() {
                                this.style.background = '#ffd700';
                                this.style.color = '#1e3c72';
                            };
                            a.onmouseleave = function() {
                                this.style.background = 'transparent';
                                this.style.color = '#ffd700';
                            };
                            linksDiv.appendChild(a);
                        });
                        
                        splashText.appendChild(linksDiv);
                    }
                    
                    splashScreen.classList.add('show');
                }
            }
            
            closeSplashScreen() {
                const splashScreen = document.getElementById('splash-screen');
                if (splashScreen) {
                    splashScreen.classList.remove('show');
                }
            }
        }
        
        // Initialize game
        let game;
        window.addEventListener('load', () => {
            game = new DungeonGame();
        });
        
    </script>
</body>
</html>